-- day6_select_set.sql

-- SELECT : 집합(SET) 연산자 ------------------------------
-- UNION, UNION ALL, INTERSECT, MINUS
--  두 개이상의 SELECT 문들의 결과(RESULT SET)들을 하나로 표현하기 위해 사용함
-- 세로로 합쳐짐(위아래로 합쳐짐) --> 조인은 가로로(옆으로) 합쳐짐
-- 첫번째 SELECT 문의 결과가 위쪽에, 두번째 SELECT 문의 결과가 아래쪽에 배치됨

-- 합집합 : UNION, UNION ALL
-- 두 SELECT 문의 결과를 하나로 합침
-- UNION : 두 SELECT 결과의 값들이 중복되는 행은 1개만 선택됨
-- UNION ALL : 두 SELECT 결과의 값들이 중복(일치) 되는 행은 제외시키지 않고 모두 선택함

-- 교집합 : INTERSECT
-- 두 SELECT 결과의 중복행만 선택

-- 차집합 : MINUS
-- 첫번재 SELECT 결과에서 두번째 SELECT 와 중복되는 행을 제외함 (뺌)

/*
사용형식 : 
     SELECT 문 1
     집합연산자
     SELECT 문 2
     집합연산자
     SELECT 문 3
     ORDER BY 순번 정렬방식;
     
주의사항 : 관계형 데이터베이스(RDB)는 2차원 사각형 테이블 구조다.
     1. 모든 SELECT 문의 SELECT 절의 컬럼 갯수가 같아야함
       => 컬럼 갯수가 다르면 DUMMY COLUMN (NULL 컬럼)을 추가해서 갯수 맞춰줌
       2. SELECT 절에 나열된 컬럼별 자료형도 같아야함
*/

-- 직원들의 사번과 직무명 조회
-- EMPLOYEE_ROLE 과 ROLE_HISTORY 에서 각각 조회해서 하나로 합침
SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE -- 22행
UNION -- 25행 : 중복행 '104 SE' 가 1개 제외됨
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY; -- 4행

SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE -- 22행
UNION ALL -- 25행 : 중복행 '104 SE' 가 모두 포함됨
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY; -- 4행

SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE -- 22행
INTERSECT -- 1행 : 중복행 '104 SE' 가 1개 선택됨
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY; -- 4행

SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE -- 22행
MINUS -- 21행 : 첫번째 SELECT문에서 중복행 '104 SE' 가 1개 제외됨
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY; -- 4행

-- SET 연산자 사용시 주의사항 확인 : 
-- 1. 두 SELECT 문의 컬럼갯수 같아야함
SELECT EMP_NAME, JOB_ID, HIRE_DATE -- 3개
FROM EMPLOYEE
WHERE DEPT_ID = '20'
UNION
--SELECT DEPT_NAME, DEPT_ID -- 2개 (ERROR)
SELECT DEPT_NAME, DEPT_ID, NULL -- 더미 컬럼으로 갯수 맞춤
FROM DEPARTMENT
WHERE DEPT_ID = '20';

-- 활용 : ROLLUP() 함수의 중간집계 위치에 원하는 문자처리 못 함
-- 해결방법은  집합 연산자를  활용할 수 있음
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '20' -- 3행
UNION
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '20'
GROUP BY DEPT_NAME;

-- 두 개 이상의 SELECT 문의 결과들을 합칠 수도 있음
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '10' -- 3행
UNION
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '10'
GROUP BY DEPT_NAME
UNION ALL
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '20' -- 3행
UNION ALL
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '20'
GROUP BY DEPT_NAME
UNION ALL
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '50' -- 3행
UNION
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '50'
GROUP BY DEPT_NAME
UNION ALL
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '60' -- 3행
UNION
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '60'
GROUP BY DEPT_NAME
UNION ALL
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '80' -- 3행
UNION
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '80'
GROUP BY DEPT_NAME
UNION ALL
SELECT EMP_NAME, JOB_ID, SALARY
FROM EMPLOYEE
WHERE DEPT_ID = '90' -- 3행
UNION
SELECT DEPT_NAME, '급여합계', SUM(SALARY)
FROM DEPARTMENT
JOIN EMPLOYEE USING (DEPT_ID)
WHERE DEPT_ID = '90'
GROUP BY DEPT_NAME
UNION ALL
SELECT '전직원', '급여총합', SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NOT NULL
UNION ALL
SELECT  '부서미배정', '급여합계', SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_ID IS NULL;

-- 반복되는 쿼리문이 너무 길어짐 ==> 상호연관 서브쿼리를 이용하거나, 프로시저 사용
-- 프로시저 : SQL 구문에 프로그래밍을 적용하는 객체임

-- 50번 부서에소속된 직원 중 관리자와 일반직원을 따로 조회해서 하나로 합쳐라.
-- 확인 : 50번 부서의 직원 정보 조회
SELECT *
FROM EMPLOYEE
WHERE DEPT_ID = '50';

SELECT EMP_ID, EMP_NAME, '관리자' 구분
FROM EMPLOYEE 
WHERE EMP_ID =  '141' AND DEPT_ID = '50'
UNION
SELECT EMP_ID, EMP_NAME, '직원' 구분
FROM EMPLOYEE 
WHERE EMP_ID !=  '141' AND DEPT_ID = '50'
--ORDER BY 3, 1; 
ORDER BY 구분, 1;

-- 집합 연산자 사용시 컬럼  또는 리터럴의 별칭(ALIAS)는 첫번째 SELECT 문에만 사용해도 됨
SELECT 'SQL을 공부하고 있습니다.' 문장, 3 순서 FROM DUAL
UNION 
SELECT '우리는 지금', 1 FROM DUAL
UNION
SELECT '아주 재미있게', 2 FROM DUAL
ORDER BY 2;
--ORDER BY 순서; -- ERROR

-- SET 연산자와 JOIN 의 관계
SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE
INTERSECT -- 1행
SELECT EMP_ID, ROLE_NAME
FROM ROLE_HISTORY;

-- 각 쿼리문의 SELECT 절에 선택한 컬럼명이 동일한 경우에는 조인으로 바꿀 수 있음
-- INTERSECT ==> USING (EMP_ID, ROLE_NAME)
-- EQUAL INNER JOIN 이 기본이므로 (104 SE) = (1104 SE) 조인으로 행이 연결될 것임
-- (104 SE-ANLY) != (104 SE) : 다르다, 조인에 포함 안 됨

-- 위의 구문을 조인으로 바꾼다면
SELECT EMP_ID, ROLE_NAME
FROM EMPLOYEE_ROLE
JOIN ROLE_HISTORY USING (EMP_ID, ROLE_NAME);

-- SET 연산자와 IN 연산자의 관계 : 
-- UNION 과 IN 은 같은 결과를 만들 수 있음
-- SELECT 절에 선택된 컬럼명이 같고, 조회하는 테이블도 같고,
-- WHERE 절에 비교값만 다른 경우에 IN 으로 바꿀 수 있음

-- 직급이 대리 또는 사원인 직원의 이름, 직급명 조회
-- 직급순 오름차순정렬, 같은 직급은 이름순 오름차순정렬 처리함
SELECT EMP_NAME, JOB_TITLE
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE IN ('대리', '사원')
ORDER BY 2, 1; -- 8행

-- UNION 으로 바꾼다면
SELECT EMP_NAME, JOB_TITLE
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '대리'
UNION
SELECT EMP_NAME, JOB_TITLE
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '사원'
ORDER BY 2, 1; -- 8행

-- 주의사항 2 : SELECT 절의 컬럼별 위아래 자료형이 같아야함
--SELECT EMP_NAME, JOB_TITLE, HIRE_DATE -- DATE 자료형
SELECT EMP_NAME, JOB_TITLE, BONUS_PCT -- NUMBER 자료형
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '대리'
UNION
SELECT EMP_NAME, JOB_TITLE, SALARY -- NUMBER  자료형
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '사원'
ORDER BY 2, 1; -- 8행












